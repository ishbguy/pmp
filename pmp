#!/usr/bin/env bash
# Copyright (c) 2025 Herbert Shen <ishbguy@hotmail.com> All Rights Reserved.
# Released under the terms of the MIT License.

# source guard
[[ $PMP_SOURCED -eq 1 ]] && return
readonly PMP_SOURCED=1
readonly PMP_ABS_SRC="$(readlink -f "${BASH_SOURCE[0]}")"
readonly PMP_ABS_DIR="$(dirname "$PMP_ABS_SRC")"

# Utils
PMP_EXIT_CODE=0
PMP_WARN_CODE=0
warn() { echo -e "WARN:" "$@" >&2; return $((++PMP_WARN_CODE)); }
error() { echo -e "ERROR:" "$@" >&2; return $((++PMP_EXIT_CODE)); }
die() { echo -e "ERROR:" "$@" >&2; exit $((++PMP_EXIT_CODE)); }
info() { echo -e "INFO:" "$@" >&2; }
debug() { [[ $DEBUG == 1 ]] && echo -e "DEBUG:" "$@" >&2 || true; }
usage() { echo -e "$HELP"; }
version() { echo -e "$PROGRAM $VERSION"; }
defined() { declare -p "$1" &>/dev/null; }
definedf() { declare -f "$1" &>/dev/null; }
is_sourced() { [[ -n ${FUNCNAME[1]} && ${FUNCNAME[1]} != "main" ]]; }
is_array() { local -a def=($(declare -p "$1" 2>/dev/null)); [[ ${def[1]} =~ a ]]; }
is_map() { local -a def=($(declare -p "$1" 2>/dev/null)); [[ ${def[1]} =~ A ]]; }
has_tool() { hash "$1" &>/dev/null; }
ensure() {
    local cmd="$1"; shift
    local -a info=($(caller 0))
    (eval "$cmd" &>/dev/null) || \
       die "${info[2]}:${info[0]}:${info[1]}:${FUNCNAME[0]} '$cmd' failed. " "$@"
}
date_cmp() { echo "$(($(date -d "$1" +%s) - $(date -d "$2" +%s)))"; }
tmpfd() { basename <(:); }
pargs() {
    ensure "[[ $# -ge 3 ]]" "Need OPTIONS, ARGUMENTS and OPTSTRING"
    ensure "[[ -n $1 && -n $2 && -n $3 ]]" "Args should not be empty."
    ensure "is_map $1 && is_map $2" "OPTIONS and ARGUMENTS should be map."

    local -n __opt="$1"
    local -n __arg="$2"
    local optstr="$3"
    shift 3

    OPTIND=1
    while getopts "$optstr" opt; do
        [[ $opt == ":" || $opt == "?" ]] && die "$HELP"
        __opt[$opt]=1
        __arg[$opt]="$OPTARG"
    done
    shift $((OPTIND - 1))
}
trap_push() {
    ensure "[[ $# -ge 2 ]]" "Usage: trap_push 'cmds' SIGSPEC..."
    local cmds="$1"; shift
    for sig in "$@"; do
        defined "trap_$sig" || declare -ga "trap_$sig"
        local -n ts="trap_$sig"
        ts+=("$cmds")
        if [[ $sig == RETURN ]]; then
            trap "trap '$cmds; trap_pop RETURN' RETURN" RETURN 
        else
            trap "$cmds" "$sig"
        fi
    done
}
trap_pop() {
    ensure "[[ $# -ge 1 ]]" "Usage: trap_pop SIGSPEC..."
    for sig in "$@"; do
        defined "trap_$sig" || declare -ga "trap_$sig"
        local -n ts="trap_$sig"
        local cmds
        # pop cmds
        ts=("${ts[@]:0:$((${#ts[@]}-1))}")
        [[ ${#ts[@]} -gt 0 ]] && cmds="${ts[-1]}"
        if [[ $sig == RETURN ]]; then
            trap "trap '$cmds' RETURN" RETURN
        else
            trap "$cmds" "$sig"
        fi
    done
}
require() {
    ensure "[[ $# -gt 2 ]]" "Not enough args."
    ensure "definedf $1" "$1 should be a defined func."

    local -a miss
    local cmd="$1"
    local msg="$2"
    shift 2
    for obj in "$@"; do
        "$cmd" "$obj" || miss+=("$obj")
    done
    [[ ${#miss[@]} -eq 0 ]] || die "$msg: ${miss[*]}."
}
require_var() { require defined "You need to define vars" "$@"; }
require_func() { require definedf "You need to define funcs" "$@"; }
require_tool() { require has_tool "You need to install tools" "$@"; }
inicfg() { require_tool git && git config --file "$@"; }

# Linux package manager agent

linux_pma() {
    local HELP=$(cat <<EOF
Linux package managment commands:

    install     install packages
    remove      remove packages
    autoremove  automatically remove all unused packages
    update      update list of available packages
    upgrade     upgrade the system by installing/upgrading packages
    search      search packages
    list        list installed packages
    info        show package infomations
    files       list all files owned by a package
    owns        list packages provide the given file
    clean       clean the local repository of retrieved package files (cache)
    source      list the repository list
EOF
)

    [[ $# -eq 0 ]] || { usage && return 0 ; }

    local distro line
    if [[ -f /etc/os-release ]]; then
        while IFS='' read -r line || [[ -n "$line" ]]; do
            if [[ $line = ID* ]]; then
                distro="${line#ID=}"
                distro="${distro//\"/}"
                distro="${distro//-/_}"
                break
            fi
        done </etc/os-release
    fi
    if [[ -n $distro ]] && declare -F "${distro}_pma" &>/dev/null; then
        echo "${distro}_pma"
    else
        echo ":"
    fi
}

arch_pma() {
    require_tool pacman
    has_tool pkgfile || { pacman -Sy --noconfirm pkgfile && pkgfile -u ; } || die "Can not install 'pkgfile'!"

    local cmd=$1 && shift
    local ita && [[ $1 == "-y" ]] && ita="--noconfirm" && shift

    case $cmd in
        install) pacman $ita -S "$@" ;;
        remove) pacman $ita -R "$@" ;;
        autoremove) pacman $ita -Rns $(pacman -Qdtq) "$@" ;;
        update) pacman -Sy "$@" ;;
        upgrade) pacman $ita -Syu "$@" ;;
        search) pacman -Ss "$@" ;;
        list) pacman -Q "$@" ;;
        info) pacman -Si "$@" ;;
        files) pkgfile -l "$@" ;;
        owns) pkgfile -s "$@" ;;
        clean) pacman $ita -Sc "$@" ;;
        source) pacman -Sl "$@";;
        * ) die "No such command: ${cmd@Q}" ;;
    esac
}

debian_pma() {
    require_tool apt
    has_tool apt-file || { apt update && apt install -y apt-file && apt-file update ; } || die "Can not install 'apt-file'!"

    local cmd=$1 && shift

    case $cmd in
        install) apt install "$@" ;;
        remove) apt remove "$@" ;;
        autoremove) apt autoremove "$@" ;;
        update) apt update "$@" ;;
        upgrade) apt upgrade "$@" ;;
        search) apt search "$@" ;;
        list) apt list --installed "$@" ;;
        info) apt show "$@" ;;
        files) apt-file list "$@" ;;
        owns) apt-file search "$@" ;;
        clean) apt clean "$@" ;;
        source) apt-cache policy "$@" ;;
        * ) die "No such command: ${cmd@Q}" ;;
    esac
}

ubuntu_pma() {
    debian_pma "$@"
}

fedora_pma() {
    require_tool dnf

    local cmd=$1 && shift

    case $cmd in
        install) dnf install "$@" ;;
        remove) dnf remove "$@" ;;
        autoremove) dnf autoremove ;;
        update) dnf check-update "$@" || true ;;
        upgrade) dnf upgrade "$@" ;;
        search) dnf search "$@" ;;
        list) dnf list --installed "$@" ;;
        info) dnf info "$@" ;;
        files) dnf repoquery --list "$@" ;;
        owns) dnf provides "$@" ;;
        clean) dnf clean all "$@" ;;
        source) dnf repolist "$@" ;;
        * ) die "No such command: ${cmd@Q}" ;;
    esac
}

redhat_pma() {
    fedora_pma "$@"
}

rhel_pma() {
    fedora_pma "$@"
}

opensuse_pma() {
    require_tool zypper

    local cmd=$1 && shift

    case $cmd in
        install) zypper install "$@" ;;
        remove) zypper remove "$@" ;;
        autoremove) zypper rm --clean-deps "$@" ;;
        update) zypper refresh "$@" ;;
        upgrade) zypper update "$@" ;;
        search) zypper search "$@" ;;
        list) zypper search --installed-only "$@" ;;
        info) zypper info "$@" ;;
        files)
            if zypper search --installed-only --match-exact "$@" &>/dev/null; then
                rpm -ql "$@"
            else
                zypper install --download-only "$@" && rpm -qlp "$(find /var/cache/zypp -name "*${*}*")"
            fi
            ;;
        owns) zypper what-provides "$@" ;;
        clean)
            [[ $1 == '-y' ]] && shift || true
            zypper clean "$@"
            ;;
        source) zypper repos "$@" ;;
        * ) die "No such command: ${cmd@Q}" ;;
    esac
}

opensuse_leap_pma() {
    opensuse_pma "$@"
}

opensuse_tumbleweed_pma() {
    opensuse_pma "$@"
}

openwrt_pma() {
    require_tool opkg
    [[ -d /var/lock ]] || mkdir -p /var/lock || die "Can not mkdir -p /var/lock!"
    has_tool find || { opkg update && opkg install findutils ; } || die "Can not install 'findutils'!"

    local cmd=$1 && shift
    local -a ita=() && [[ $1 == "-y" ]] \
        && ita=(--force-depends --force-maintainer --force-reinstall --force-overwrite
                --force-downgrade --force-space --force-postinstall --force-remove --force-checksum) \
        && shift

    case $cmd in
        install) opkg install "${ita[@]}" "$@" ;;
        remove) opkg remove "${ita[@]}" "$@" ;;
        autoremove) opkg remove --autoremove "${ita[@]}" "$@" ;;
        update) opkg update "$@" || true ;;
        upgrade) opkg upgrade "${ita[@]}" "$@" ;;
        search) opkg find "$@" ;;
        list) opkg list-installed "$@" ;;
        info) opkg info "$@" ;;
        files) opkg files "$@" ;;
        owns)
            local file pkg
            for file in "$@"; do
                if [[ -e $file ]]; then
                    pkg="$(opkg search "$PWD/$file")"
                else
                    pkg="$(opkg search "$(which "$file")")"
                fi
                echo "$file: $pkg"
            done ;;
        clean) rm -rf /var/opkg-lists/* ;;
        source)
            if [[ ${#@} -eq 0 ]]; then
                grep '^src' /etc/opkg.conf $(find /etc/opkg -name *.conf)
            else
                grep '^src' "$@"
            fi ;;
        * ) die "No such command: ${cmd@Q}" ;;
    esac
}

immortalwrt_pma() {
    openwrt_pma "$@"
}

pmp_cma() {
    local HELP=$(cat <<EOF
Configuration managment commands:

    init        init a new configuration repo
    clone       clone a configuration repo
    config      configuration operations of pmp and git repo
    pin         add package deps to pmp configuration file
    unpin       rmove package deps to pmp configuration file
    keep        add configuration files to the repo
    free        remove configuration files from the repo
    sync        install dependence packages and configure files
    deps        show packages deps

Others commands will be passed to git, you can type 'git help <cmd>' for help.
EOF
)
    local cmd=$1 && shift
    local obj

    case $cmd in
        pin)   for obj in "$@"; do pmp_git config "cmd.$obj" true; done ;;
        unpin) for obj in "$@"; do pmp_git config --unset "cmd.$obj" ; done ;;
        keep)
            [[ $# -eq 1 || $# -eq 2 ]] || die "Usage: pmp keep <config> [target]"
            [[ -e $1 ]] || die "No such file or directory."

            local cfg="$1" && [[ $cfg =~ ^/ ]] || cfg="$PWD/$cfg"
            local source="$(readlink -f "$cfg")"
            local target="$PMP_REPO/${2:-$(basename "$cfg")}"

            [[ ! -e $target ]] || die "Configuration file or directory is already exist: $target"

            # if it's user dotfiles, use $HOME as path prefix
            [[ ! $cfg =~ $HOME ]] || cfg="${cfg/$HOME/\$HOME}"

            [[ -d ${target%/*} ]] || mkdir -p "${target%/*}"
            # copy and backup the configurations first
            cp -rp "$source" "$target" && eval mv "$cfg" "$cfg-$(date +%Y%m%d%H%M%S)" \
                && eval ln -s "$(readlink -f "$target")" "$cfg" \
                && pmp_git config "cfg.'${target##"$PMP_REPO"/}'.link" "$cfg" \
                && pmp_git add "$PMP_CONF" "${target##"${PMP_REPO}"/}" \
                && pmp_git commit -m "keep $cfg" \
                || die "Failed to keep $1"
            ;;
        free)
            [[ $# -gt 0 ]] || die "Usage: pmp free <config> ..."

            local origin=""

            for cfg in "$@"; do
                [[ -e $PMP_REPO/$cfg ]] || error "No such file or directory in repo: $cfg" || continue
                if pmp config --get-regexp "cfg.'$cfg'.link" &>/dev/null; then
                    origin="$(pmp config --get-regexp "cfg.'$cfg'.link" 2>/dev/null | awk '{print $2}')"
                    [[ -e $origin ]] || warn "Can not find the link: $origin -> $cfg" >&2
                    eval rm -rf "$origin" && eval cp -rp "$PMP_REPO/$cfg" "$origin" \
                        && pmp_git config --unset "cfg.'$cfg'.link" \
                        && pmp_git add "$PMP_CONF" \
                        && pmp_git rm -r "$cfg" \
                        && pmp_git commit -m "free $cfg" \
                        || error "Failed to free $cfg"
                else
                    error "${cfg@Q} is not directly kept as a file, maybe kept in a directory."
                fi
            done
            return "$PMP_EXIT_CODE"
            ;;
        sync)
            ;;
        deps)
            ;;
        help) usage ;;
        *) die "No such command: ${cmd@Q}" ;;
    esac
}

pmp_link_repo() {
    local repo="$1"
    [[ -d $repo ]] || die "No such directory ${repo@Q}, fail to create or link repo!"
    # return when $repo and $PMP_REPO are the same
    [[ $(readlink -f "$repo") != $(readlink -f "$PMP_REPO") ]] || return 0
    # backup the conf dir and file first
    [[ ! -d $PMP_REPO ]] || mv "$PMP_REPO" "$PMP_REPO-$(date +%Y%m%d%H%M%S)"
    ln -s "$(readlink -f "$repo")" "$PMP_REPO"
}

pmp_git() {
    local cmd=$1 && shift
    local tmpfile="$(mktemp -u)"

    case $cmd in
        init)
            if [[ $# -eq 0 ]]; then
                git init "$PMP_REPO" | tee "$tmpfile"
            else
                git init "$@" | tee "$tmpfile"
            fi
            # git init success
            if [[ ${PIPESTATUS[0]} -eq 0 ]]; then
                local repo="$(dirname "$(awk '/Initialized/ {print $6}' "$tmpfile")")"
                rm -rf "$tmpfile"
                (cd "$repo" && touch pmp.conf && git add pmp.conf && git commit -am "first init repo")
                pmp_link_repo "$repo"
            else
                rm -rf "$tmpfile" && die "pmp init failed!"
            fi ;;
        clone)
            git clone "$@" 2>&1 | tee "$tmpfile"
            # git clone success
            if [[ ${PIPESTATUS[0]} -eq 0 ]]; then
                local repo="$(awk '/Cloning into/ {print $3}' "$tmpfile" | sed -r "s/\.{3}$//g;s/'//g")"
                rm -rf "$tmpfile"
                pmp_link_repo "$repo"
            else
                rm -rf "$tmpfile" && die "pmp clone failed!"
            fi ;;
        config)
            # first init pmp conf
            [[ -d $PMP_REPO && -e $PMP_CONF ]] || { mkdir -p "$PMP_REPO" && touch "$PMP_CONF" ; }
            if [[ $* =~ (--local|--global|--system|--worktree) ]]; then
                git -C "$PMP_REPO" config "$@"
            else
                git config --file "$PMP_CONF" "$@"
            fi ;;
        *) git -C "$PMP_REPO" "$cmd" "$@" ;;
    esac
}

pmp_self_install() {
    local -a miss=() fails=()
    echo -e "Checking for dependences:"
    for t in "${deps[@]}"; do
        if has_tool "$t"; then
            echo -e "$t ... OK"
        else
            echo -e "$t ... NOT FOUNDED" && miss+=("$t")
        fi
    done
    [[ ${#miss[@]} -eq 0 ]] || {
        echo -e "Need to install: ${miss[*]}"
        $(linux_pma) update
        for t in "${miss[@]}"; do
            $(linux_pma) install -y "$t" || fails+=("$t")
        done
        if [[ ${#fails[@]} -eq 0 ]]; then
            echo "Self installation done!"
        else
            die "Failed to install tools: ${fails[*]}"
        fi
    }
}

pmp() {
    local PROGRAM="$(basename "${BASH_SOURCE[0]}")"
    local VERSION="v0.2.0"
    local HELP=$(cat <<EOF
$PROGRAM $VERSION
$PROGRAM [-frIvhD] [file|dir] <cmd> args...

    -f  specify the configuration file
    -r  specify the repo directory
    -I  self install and update
    -v  print version number
    -h  print this help message
    -D  turn on debug mode

General commands:

    self-install   self install and update
    version        print version number
    help           print this help message

$(linux_pma help)

$(pmp_cma help)

This program is released under the terms of the MIT License.
EOF
)
    local -a deps=(git awk sed)
    local -A opts=() args=()
    pargs opts args 'hvDIf:r:' "$@"
    shift $((OPTIND - 1))
    [[ ${opts[D]} ]] && set -x
    [[ ${opts[h]} ]] && usage && return 0
    [[ ${opts[v]} ]] && version && return 0
    [[ ${opts[I]} || $1 == "self-install" ]] && { pmp_self_install ; return $? ; }

    require_tool "${deps[@]}"

    # run without args will print help message
    [[ $# -gt 0 ]] || { usage && return 0; } 

    # configure default variables
    local PMP_REPO="${opts[r]:-${PMP_REPO:-$HOME/.pmp}}"
    local PMP_CONF="${opts[f]:-${PMP_CONF:-$PMP_REPO/pmp.conf}}"

    [[ -d $PMP_REPO ]] || mkdir -p "$PMP_REPO" || die "Failed to create pmp repo dir: ${PMP_REPO}"

    case $1 in
        # Linux package managment commands
        install|remove|autoremove|update|upgrade|search|list|info|files|owns|clean|source)
            $(linux_pma) "$@" ;;
        # Configuration managment commands
        pin|unpin|keep|free|sync|deps) pmp_cma "$@" ;;
        # General commands
        version) version ;;
        help) usage ;;
        # Others will be passed to pmp_git
        *) pmp_git "$@" ;;
    esac
}

is_sourced || pmp "$@"

# vim:set ft=sh ts=4 sw=4:
