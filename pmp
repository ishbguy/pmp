#!/usr/bin/env bash
# Copyright (c) 2025 Herbert Shen <ishbguy@hotmail.com> All Rights Reserved.
# Released under the terms of the MIT License.

# source guard
[[ $PMP_SOURCED -eq 1 ]] && return
readonly PMP_SOURCED=1
readonly PMP_ABS_SRC="$(readlink -f "${BASH_SOURCE[0]}")"
readonly PMP_ABS_DIR="$(dirname "$PMP_ABS_SRC")"

# Utils
PMP_EXIT_CODE=0
warn() { echo -e "$@" >&2; ((++PMP_EXIT_CODE)); return ${WERROR:-1}; }
die() { echo -e "$@" >&2; exit $((++PMP_EXIT_CODE)); }
debug() { [[ $DEBUG == 1 ]] && echo "$@" || true; }
usage() { echo -e "$HELP"; }
version() { echo -e "$PROGRAM $VERSION"; }
defined() { declare -p "$1" &>/dev/null; }
definedf() { declare -f "$1" &>/dev/null; }
is_sourced() { [[ -n ${FUNCNAME[1]} && ${FUNCNAME[1]} != "main" ]]; }
is_array() { local -a def=($(declare -p "$1" 2>/dev/null)); [[ ${def[1]} =~ a ]]; }
is_map() { local -a def=($(declare -p "$1" 2>/dev/null)); [[ ${def[1]} =~ A ]]; }
has_tool() { hash "$1" &>/dev/null; }
ensure() {
    local cmd="$1"; shift
    local -a info=($(caller 0))
    (eval "$cmd" &>/dev/null) || \
       die "${info[2]}:${info[0]}:${info[1]}:${FUNCNAME[0]} '$cmd' failed. " "$@"
}
date_cmp() { echo "$(($(date -d "$1" +%s) - $(date -d "$2" +%s)))"; }
tmpfd() { basename <(:); }
pargs() {
    ensure "[[ $# -ge 3 ]]" "Need OPTIONS, ARGUMENTS and OPTSTRING"
    ensure "[[ -n $1 && -n $2 && -n $3 ]]" "Args should not be empty."
    ensure "is_map $1 && is_map $2" "OPTIONS and ARGUMENTS should be map."

    local -n __opt="$1"
    local -n __arg="$2"
    local optstr="$3"
    shift 3

    OPTIND=1
    while getopts "$optstr" opt; do
        [[ $opt == ":" || $opt == "?" ]] && die "$HELP"
        __opt[$opt]=1
        __arg[$opt]="$OPTARG"
    done
    shift $((OPTIND - 1))
}
trap_push() {
    ensure "[[ $# -ge 2 ]]" "Usage: trap_push 'cmds' SIGSPEC..."
    local cmds="$1"; shift
    for sig in "$@"; do
        defined "trap_$sig" || declare -ga "trap_$sig"
        local -n ts="trap_$sig"
        ts+=("$cmds")
        if [[ $sig == RETURN ]]; then
            trap "trap '$cmds; trap_pop RETURN' RETURN" RETURN 
        else
            trap "$cmds" "$sig"
        fi
    done
}
trap_pop() {
    ensure "[[ $# -ge 1 ]]" "Usage: trap_pop SIGSPEC..."
    for sig in "$@"; do
        defined "trap_$sig" || declare -ga "trap_$sig"
        local -n ts="trap_$sig"
        local cmds
        # pop cmds
        ts=("${ts[@]:0:$((${#ts[@]}-1))}")
        [[ ${#ts[@]} -gt 0 ]] && cmds="${ts[-1]}"
        if [[ $sig == RETURN ]]; then
            trap "trap '$cmds' RETURN" RETURN
        else
            trap "$cmds" "$sig"
        fi
    done
}
require() {
    ensure "[[ $# -gt 2 ]]" "Not enough args."
    ensure "definedf $1" "$1 should be a defined func."

    local -a miss
    local cmd="$1"
    local msg="$2"
    shift 2
    for obj in "$@"; do
        "$cmd" "$obj" || miss+=("$obj")
    done
    [[ ${#miss[@]} -eq 0 ]] || die "$msg: ${miss[*]}."
}
require_var() { require defined "You need to define vars" "$@"; }
require_func() { require definedf "You need to define funcs" "$@"; }
require_tool() { require has_tool "You need to install tools" "$@"; }
inicfg() { require_tool git && git config --file "$@"; }

# Linux package manager agent

linux_pma() {
    local distro line
    if [[ -f /etc/os-release ]]; then
        while IFS='' read -r line || [[ -n "$line" ]]; do
            if [[ $line = ID* ]]; then
                distro="${line#ID=}"
                distro="${distro//\"/}"
                break
            fi
        done </etc/os-release
    fi
    if [[ -n $distro ]] && declare -F "${distro}_pma" &>/dev/null; then
        echo "${distro}_pma"
    else
        echo ":"
    fi
}

arch_pma() {
    require_tool pacman
    has_tool pkgfile || { pacman -S --noconfirm pkgfile && pkgfile -u ; } || die "Can not install 'pkgfile'!"

    local cmd=$1 && shift

    case $cmd in
        install) pacman -S "$@" ;;
        remove) pacman -R "$@" ;;
        autoremove) pacman -Rns $(pacman -Qdtq) "$@" ;;
        update) pacman -Sy "$@" ;;
        upgrade) pacman -Syu "$@" ;;
        search) pacman -Ss "$@" ;;
        list) pacman -Q "$@" ;;
        info) pacman -Si "$@" ;;
        files) pkgfile -l "$@" ;;
        owns) pkgfile -s "$@" ;;
        clean) pacman -Sc "$@" ;;
        source) pacman -Sl "$@";;
        * ) die "No such command: ${cmd@Q}" ;;
    esac
}

debian_pma() {
    require_tool apt
    has_tool apt-file || { apt install -y apt-file && apt-file update ; } || die "Can not install 'apt-file'!"

    local cmd=$1 && shift

    case $cmd in
        install) apt install "$@" ;;
        remove) apt remove "$@" ;;
        autoremove) apt autoremove "$@" ;;
        update) apt update "$@" ;;
        upgrade) apt upgrade "$@" ;;
        search) apt search "$@" ;;
        list) apt list --installed "$@" ;;
        info) apt show "$@" ;;
        files) apt-file list "$@" ;;
        owns) apt-file search "$@" ;;
        clean) apt clean "$@" ;;
        source) apt-cache policy "$@" ;;
        * ) die "No such command: ${cmd@Q}" ;;
    esac
}

ubuntu_pma() {
    debian_pma "$@"
}

fedora_pma() {
    require_tool dnf

    local cmd=$1 && shift

    case $cmd in
        install) dnf install "$@" ;;
        remove) dnf remove "$@" ;;
        autoremove) dnf autoremove "$@" ;;
        update) dnf check-update "$@" ;;
        upgrade) dnf upgrade "$@" ;;
        search) dnf search "$@" ;;
        list) dnf list installed "$@" ;;
        info) dnf info "$@" ;;
        files) dnf repoquery --list "$@" ;;
        owns) dnf provides "$@" ;;
        clean) dnf clean all "$@" ;;
        source) dnf repolist "$@" ;;
        * ) die "No such command: ${cmd@Q}" ;;
    esac
}

redhat_pma() {
    local version line
    if [[ -f /etc/os-release ]]; then
        while IFS='' read -r line || [[ -n "$line" ]]; do
            if [[ $line = VERSION_ID* ]]; then
                version="${line#VERSION_ID=}"
                version="${version//\"/}"
                break
            fi
        done </etc/os-release
    fi

    [[ $version -lt 8 ]] || { fedora_pma "$@" ; return $? ; }

    require_tool yum
    has_tool repoquery || { yum install -y yum-utils ; } || die "Can not install 'yum-utils'!"

    local cmd=$1 && shift

    case $cmd in
        install) yum install "$@" ;;
        remove) yum remove "$@" ;;
        autoremove) yum autoremove "$@" ;;
        update) yum check-update "$@" ;;
        upgrade) yum upgrade "$@" ;;
        search) yum search "$@" ;;
        list) yum list installed "$@" ;;
        info) yum info "$@" ;;
        files) repoquery --list "$@" ;;
        owns) repoquery --provides "$@" ;;
        clean) yum clean all "$@" ;;
        source) yum repolist "$@" ;;
        * ) die "No such command: ${cmd@Q}" ;;
    esac
}

opensuse_pma() {
    require_tool zypper

    local cmd=$1 && shift

    case $cmd in
        install) zypper install "$@" ;;
        remove) zypper remove "$@" ;;
        autoremove) zypper rm --clean-deps "$@" ;;
        update) zypper refresh "$@" ;;
        upgrade) zypper update "$@" ;;
        search) zypper search "$@" ;;
        list) zypper search --installed "$@" ;;
        info) zypper info "$@" ;;
        files) zypper packages --files "$@" ;;
        owns) zypper wp "$@" ;;
        clean) zypper clean "$@" ;;
        source) zypper lr "$@" ;;
        * ) die "No such command: ${cmd@Q}" ;;
    esac
}

gentoo_pma() {
    require_tool emerge
    has_tool equery || { emerge gentoolkit ; } || die "Can not install 'gentoolkit'!"

    local cmd=$1 && shift

    case $cmd in
        install) emerge "$@" ;;
        remove) emerge --unmerge "$@" ;;
        autoremove) emerge --depclean "$@" ;;
        update) emerge --sync "$@" ;;
        upgrade) emerge -avuDU "$@" ;;
        search) emerge --search "$@" ;;
        list) emerge -ep "$@" ;;
        info) emerge -pv "$@" ;;
        files) equery files "$@" ;;
        owns) equery belongs "$@" ;;
        clean) eclean-dist "$@" ;;
        source) eselect repository list "$@" ;;
        * ) die "No such command: ${cmd@Q}" ;;
    esac
}

openwrt_pma() {
    require_tool opkg
    has_tool find || { opkg install findutils ; } || die "Can not install 'findutils'!"

    local cmd=$1 && shift

    case $cmd in
        install) opkg install "$@" ;;
        remove) opkg remove "$@" ;;
        autoremove) true ;;
        update) opkg update "$@" ;;
        upgrade) opkg upgrade "$@" ;;
        search) opkg find "$@" ;;
        list) opkg list-installed "$@" ;;
        info) opkg info "$@" ;;
        files) opkg files "$@" ;;
        owns)
            local file pkg
            for file in "$@"; do
                if [[ -e $file ]]; then
                    pkg="$(opkg search "$PWD/$file")"
                else
                    pkg="$(opkg search "$(which "$file")")"
                fi
                echo "$file: $pkg"
            done ;;
        clean) opkg clean "$@" ;;
        source)
            if [[ ${#@} -eq 0 ]]; then
                grep '^src' /etc/opkg.conf $(find /etc/opkg -name *.conf)
            else
                grep '^src' "$@"
            fi ;;
        * ) die "No such command: ${cmd@Q}" ;;
    esac
}

pmp_cma() {
    local cmd=$1 && shift
    local obj

    case $cmd in
        pin)   for obj in "$@"; do pmp_git config "cmds.$obj" true; done ;;
        unpin) for obj in "$@"; do pmp_git config --unset "cmds.$obj" ; done ;;
        keep)
            [[ $# -eq 1 || $# -eq 2 ]] || die "Usage: pmp keep <config> [target]"
            [[ -e $1 ]] || die "No such file or directory."

            local cfg="$1" && [[ $cfg =~ ^/ ]] || cfg="$PWD/$cfg"
            local source="$(readlink -f "$cfg")"
            local target="$PMP_REPO/${2:-$(basename "$cfg")}"

            [[ ! -e $target ]] || die "Configuration file or directory is already exist: $target"

            # if it's user dotfiles, use $HOME as path prefix
            [[ ! $cfg =~ $HOME ]] || cfg="${cfg/$HOME/\$HOME}"

            [[ -d ${target%/*} ]] || mkdir -p "${target%/*}"
            # copy and backup the configurations first
            cp -rp "$source" "$target" && eval mv "$cfg" "$cfg-$(date +%Y%m%d%H%M%S)" \
                && eval ln -s "$(readlink -f "$target")" "$cfg" \
                && pmp_git config "cfg.'${target##"$PMP_REPO"/}'.link" "$cfg" \
                && pmp_git add "$PMP_CONF" "${target##"${PMP_REPO}"/}" \
                && pmp_git commit -m "keep $cfg"
            ;;
        free)
            [[ $# -gt 0 ]] || die "Usage: pmp free <config> ..."

            local -a miss=()
            local origin=""

            for cfg in "$@"; do
                [[ -e $PMP_REPO/$cfg ]] || warn "No such file or directory in repo: $cfg" || continue
                if pmp config --get-regexp "cfg.'$cfg'.link" &>/dev/null; then
                    origin="$(pmp config --get-regexp "cfg.'$cfg'.link" 2>/dev/null | awk '{print $2}')"
                    [[ -e $origin ]] || echo "Warn: can not find the link: $origin -> $cfg" >&2
                    eval rm -rf "$origin" && eval cp -rp "$PMP_REPO/$cfg" "$origin" \
                        && pmp_git config --unset "cfg.'$cfg'.link" \
                        && pmp_git add "$PMP_CONF" \
                        && pmp_git rm -r "$cfg" \
                        && pmp_git commit -m "free $cfg"
                else
                    warn "${cfg@Q} is not directly kept as a file, maybe kept as a directory."
                fi
            done
            return "$PMP_EXIT_CODE"
            ;;
        sync)
            ;;
        deps)
            ;;
        *) die "No such command: ${cmd@Q}" ;;
    esac
}

pmp_link_repo() {
    local repo="$1"
    [[ -d $repo ]] || die "No such directory ${repo@Q}, fail to create or link repo!"
    # return when $repo and $PMP_REPO are the same
    [[ $(readlink -f "$repo") != $(readlink -f "$PMP_REPO") ]] || return 0
    # backup the conf dir and file first
    [[ ! -d $PMP_REPO ]] || mv "$PMP_REPO" "$PMP_REPO-$(date +%Y%m%d%H%M%S)"
    ln -s "$(readlink -f "$repo")" "$PMP_REPO"
}

pmp_git() {
    local cmd=$1 && shift
    local tmpfile="$(mktemp -u)"

    case $cmd in
        init)
            if [[ $# -eq 0 ]]; then
                git init "$PMP_REPO" | tee "$tmpfile"
            else
                git init "$@" | tee "$tmpfile"
            fi
            # git init success
            if [[ ${PIPESTATUS[0]} -eq 0 ]]; then
                local repo="$(dirname "$(awk '/Initialized/ {print $6}' "$tmpfile")")"
                rm -rf "$tmpfile"
                (cd "$repo" && touch pmp.conf && git add pmp.conf && git commit -am "first init pmp")
                pmp_link_repo "$repo"
            else
                rm -rf "$tmpfile" && die "pmp init failed!"
            fi ;;
        clone)
            git clone "$@" 2>&1 | tee "$tmpfile"
            # git clone success
            if [[ ${PIPESTATUS[0]} -eq 0 ]]; then
                local repo="$(awk '/Cloning into/ {print $3}' "$tmpfile" | sed -r "s/\.{3}$//g;s/'//g")"
                rm -rf "$tmpfile"
                pmp_link_repo "$repo"
            else
                rm -rf "$tmpfile" && die "pmp clone failed!"
            fi ;;
        config)
            # first init pmp conf
            [[ -d $PMP_REPO && -e $PMP_CONF ]] || { mkdir -p "$PMP_REPO" && touch "$PMP_CONF" ; }
            if [[ $* =~ (--local|--global|--system|--worktree) ]]; then
                git -C "$PMP_REPO" config "$@"
            else
                git config --file "$PMP_CONF" "$@"
            fi ;;
        *) git -C "$PMP_REPO" "$cmd" "$@" ;;
    esac
}

pmp() {
    local PROGRAM="$(basename "${BASH_SOURCE[0]}")"
    local VERSION="v0.2.0"
    local HELP=$(cat <<EOF
$PROGRAM $VERSION
$PROGRAM [-hvD] <cmd> args...

    -h  print this help message 
    -v  print version number
    -D  turn on debug mode

Linux package managment commands:

    install     install packages
    remove      remove packages
    autoremove  automatically remove all unused packages
    update      update list of available packages
    upgrade     upgrade the system by installing/upgrading packages
    search      search packages
    list        list installed packages
    info        show package infomations
    files       list all files owned by a package
    owns        list packages provide the given file
    clean       clean the local repository of retrieved package files (cache)
    source      list the repository list

Configuration managment commands:

    init        init a new configuration repo
    clone       clone a configuration repo
    config      configuration operations of pmp and git repo
    pin         add package deps to pmp configuration file
    unpin       rmove package deps to pmp configuration file
    keep        add configuration files to the repo
    free        remove configuration files from the repo
    sync        install dependence packages and configure
    deps        show packages deps

Others commands will be passed to git, you can type 'git help <cmd>' for help.

This program is released under the terms of the MIT License.
EOF
)
    local -A opts=() args=()
    pargs opts args 'hvD' "$@"
    shift $((OPTIND - 1))
    [[ ${opts[D]} ]] && set -x
    [[ ${opts[h]} ]] && usage && return 0
    [[ ${opts[v]} ]] && version && return 0

    require_tool git awk sed

    # run without args will print help message
    [[ $# -gt 0 ]] || { usage && return 0; } 

    # configure default variables
    local PMP_REPO="${PMP_REPO:-$HOME/.pmp}"
    local PMP_CONF="${PMP_CONF:-$PMP_REPO/pmp.conf}"

    [[ -d $PMP_REPO ]] || mkdir -p "$PMP_REPO" || die "Can not create pmp repo dir: ${PMP_REPO}"

    case $1 in
        # Linux package managment commands
        install|remove|autoremove|update|upgrade|search|list|info|files|owns|clean|source)
            $(linux_pma) "$@" ;;
        # Configuration managment commands
        pin|unpin|keep|free|sync|deps) pmp_cma "$@" ;;
        # Misc commands
        version) version ;;
        help) usage ;;
        # Others will be passed to pmp_git
        *) pmp_git "$@" ;;
    esac
}

is_sourced || pmp "$@"

# vim:set ft=sh ts=4 sw=4:
